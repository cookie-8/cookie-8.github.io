{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction nothing copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter1/":{"url":"Chapter1/","title":"第一章 js","keywords":"","body":"第一章 js基础 copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter1/基础.html":{"url":"Chapter1/基础.html","title":"基础","keywords":"","body":"基础 new 构造函数返回原始值将被忽略，按默认返回当前 this 对象, 返回对象将使得 new 操作符无用 function create(Con, ...args) { let obj = {} Object.setPrototypeOf(obj, Con.prototype) let result = Con.apply(obj, args) return result instanceof Object ? result : obj } evnetloop microTask macroTask 继承 原型继承，构造函数继承，组合继承 实现 promise import、require、export、module.exports eventEmitter class Event { constructor() { this.events = Object.create(null); } on(name, fn) { if (!this.events[name]) { this.events[name] = [] } this.events[name].push(fn); return this; } emit(name, ...args) { if (!this.events[name]) { return this; } const fns = this.events[name] fns.forEach(fn => fn.call(this, ...args)) return this; } off(name,fn) { if (!this.events[name]) { return this; } if (!fn) { this.events[name] = null return this } const index = this.events[name].indexOf(fn); this.events[name].splice(index, 1); return this; } once(name,fn) { const only = () => { fn.apply(this, arguments); this.off(name, only); }; this.on(name, only); return this; } } JSON.stringify 的5个特性 JSON.stringify(obj: object, str: string[] | Function , holder: number | string) 7.1 第二个参数为数组时，可以过滤对象的key，找出需要的数据 7.2 第二个参数为函数时，如果返回 undefined，则不会打印键值对 7.3 第三个参数控制最后一个字符串的间距。如果参数是一个数字，则字符串化中的每个级别都将缩进这个数量的空格字符。 7.4 如果第三个参数是 string，那么将使用它来代替7.3中显示的空格字符 7.5 JSON.stringify返回这个函数的结果并对其进行序列化，而不是将整个对象转换为字符串 const user = { firstName : \"Prateek\", lastName : \"Singh\", age : 26, toJSON() { return { fullName: `${this.firstName} + ${this.lastName}` }; } } console.log(JSON.stringify(user)); // 结果 // \"{ \"fullName\" : \"Prateek Singh\"}\" copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter1/ts.html":{"url":"Chapter1/ts.html","title":"ts","keywords":"","body":"ts copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter1/正则.html":{"url":"Chapter1/正则.html","title":"正则","keywords":"","body":"正则 子匹配 (), $0为整个匹配, $1为第一个子匹配... 非捕获匹配 (?:x) , 例如 /(?:foo){1,2}/ 先行断言 x(?=y) ,例如 /Jack(?=Sprat)/会匹配到'Jack'仅仅当它后面跟着'Sprat'。 后行断言 (? 例如 /(?会匹配到'Sprat'仅仅当它前面是'Jack' 正向否定查找 x(?!y) 例如 /\\d+(?!\\.)/匹配一个数仅仅当这个数后面没有跟小数点的时候 /(a)(b)\\1\\2/ \\1代表第一个捕获的子匹配 copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter1/技巧.html":{"url":"Chapter1/技巧.html","title":"技巧","keywords":"","body":"技巧 格式化时间 export function formatDate(oldDate, fmt) { let date = new Date(); if (typeof oldDate === 'string' || typeof oldDate === 'number') { date = new Date(+oldDate); } else { date = oldDate; } if (/(y+)/.test(fmt)) { fmt = fmt.replace( RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length) ); } let o = { 'M+': date.getMonth() + 1, 'd+': date.getDate(), 'h+': date.getHours(), 'm+': date.getMinutes(), 's+': date.getSeconds() }; function padLeftZero(str) { return ('00' + str).substr(str.length); } for (let k in o) { if (new RegExp(`(${k})`).test(fmt)) { let str = o[k] + ''; fmt = fmt.replace( RegExp.$1, RegExp.$1.length === 1 ? str : padLeftZero(str) ); } } return fmt; } 快速获取 url 中的参数 function getUrlParams(param) { var query = window.location.search.substring(1); var vars = query.split('&'); for (var i = 0; i 不考虑ie :smile: var urlParams = new URLSearchParams('?post=1234&action=edit'); console.log(urlParams.get('action')); // \"edit\" 移动端判断浏览器类型 BrowserInfo = { isAndroid: Boolean(navigator.userAgent.match(/android/gi)), isIphone: Boolean(navigator.userAgent.match(/iphone|ipod/gi)), isIpad: Boolean(navigator.userAgent.match(/ipad/gi)), isWeixin: Boolean(navigator.userAgent.match(/MicroMessenger/gi)), isAli: Boolean(navigator.userAgent.match(/AlipayClient/gi)), isPhone: Boolean( /(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent) ) }; 防抖 节流 function debounce(func, wait) { let timeout; return function() { let context = this; let args = arguments; if (timeout) clearTimeout(timeout); timeout = setTimeout(() => { func.apply(context, args); }, wait); }; } function throttle(func, wait) { let previous = 0; return function() { let now = Date.now(); let context = this; let args = arguments; if (now - previous > wait) { func.apply(context, args); previous = now; } }; } copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter1/柯里化.html":{"url":"Chapter1/柯里化.html","title":"柯里化","keywords":"","body":"柯里化 copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter1/this口诀.html":{"url":"Chapter1/this口诀.html","title":"this的6种指向","keywords":"","body":"this的6种指向 世界尽头 点石成金 指腹为婚 山盟海誓 内有乾坤 军令如山 copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter1/继承.html":{"url":"Chapter1/继承.html","title":"es5与es6继承实现","keywords":"","body":"es5 与 es6 继承实现 原型链继承 子类的原型就是父类的实例 Son.prototype = new Parent() Son.prototype.constructor = Son 借用构造函数继承 借鸡生蛋 function Son() { Parent.call(this, args) this.son = \"李志强\" } 组合继承 function Son() { Parent.call(this, args) this.son = \"李志强\" } Son.prototype = new Parent() Son.prototype.constructor = Son 还有其他方式，主要是prototype有些不同 Son.prototype = Object.create(Parent.prototype) Son.prototype.constructor = Son es6 继承 function F(){} F.prototype = superClass.prototype subClass.prototype = new F() subClass.prototype.constructor = subClass //接下来subClass.__proto__ = superClass //_inherits核心思想就是下面两句 subClass.prototype.__proto__ = superClass.prototype subClass.__proto__ = superClass // 静态属性、方法 copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter1/实现call&apply&bind.html":{"url":"Chapter1/实现call&apply&bind.html","title":"call apply bind","keywords":"","body":"call apply bind call Function.prototype.myCall = function (context, ...args) { // 1.判断context是否为空 if (context === undefined || context === null) { context = window } // 2.给函数设置新的this指向 let fn = new Symbol() context[fn] = this const result = context[fn](...args) delete context[fn] return result } apply Function.prototype.myApply = function (context, ...args) { // 1.判断context是否为空 if (context === undefined || context === null) { context = window } // 2.给函数设置新的this指向 let fn = new Symbol() context[fn] = this const result = context[fn](...args) delete context[fn] return result } bind Function.prototype.myBind = function (context, ...args) { // 1. 检查context是否为空 if (context === undefined || context === null) { context = window } const fn = new Symbol() context[fn] = this const _this = this // 保存this const result = function (...innerArgs) { // 2.检查是否将bind之后的函数作为构造函数 if (this instanceof _this) { this[fn] = _this this[fn](...args, ...innerArgs) delete this[fn] } else { context[fn](...args, ...innerArgs) } } result.prototype = Object.create(this.prototype) delete context[fn] return result } copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter1/实现new.html":{"url":"Chapter1/实现new.html","title":"new","keywords":"","body":"new 实现new，关键点在于函数返回的结果究竟是不是对象或者函数，如果不是，需要返回构造的对象; 特别注意还要记得设置原型链 function myNew(fn, ...args) { const obj = {} // 构造一个对象 obj.__proto__ = fn.prototype // 设置原型 // 设置原型还可以更优雅 // const obj = Object.create(fn.prototype) const result = fn.call(obj, ...args) if ( (result && typeof result === \"object\") || (result && typeof result === \"function\") ) { return result } return obj } copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter1/promise.html":{"url":"Chapter1/promise.html","title":"promise","keywords":"","body":"promise class MyPromise { constructor(executor) { this.status = \"pending\" this.value = undefined this.reason = undefined this.onResovleCallback = [] this.onRejectCallback = [] executor(this.resovle, this.reject) } resovle = (value) => { if (this.status === \"pending\") { this.status = \"fulfilled\" this.value = value this.onResovleCallback.forEach((fn) => fn()) } } reject = (reason) => { if (this.status === \"pending\") { this.status = \"rejected\" this.reason = reason this.onRejectCallback.forEach((fn) => fn()) } } then = (onFulfilled, onRejected) => { const promise = new MyPromise((resolve, reject) => { if (this.status === \"fulfilled\") { setTimeout(() => { const x = onFulfilled(this.value) x instanceof MyPromise ? x.then(resolve, reject) : resolve(x) }, 0) } if (this.status === \"rejected\") { setTimeout(() => { const x = onRejected(this.reason) x instanceof MyPromise ? x.then(resolve, reject) : reject(x) }, 0) } if (this.status === \"pending\") { this.onResovleCallback.push(() => { setTimeout(() => { const x = onFulfilled(this.value) x instanceof MyPromise ? x.then(resolve, reject) : resolve(x) }, 0) }) this.onRejectCallback.push(() => { setTimeout(() => { const x = onRejected(this.reason) x instanceof MyPromise ? x.then(resolve, reject) : reject(x) }, 0) }) } }) return promise } static all = (promises) => { let count = 0 const result = [] return new MyPromise((resolve, reject) => { promises.forEach((promise, index) => { promise.then( (res) => { result[index] = res count++ if (count === promises.length) { resolve(result) } }, (reason) => { reject(reason) }, ) }) }) } static race = (promises) => { return new MyPromise((resolve, reject) => { promises.forEach((promise) => { promise.then( (res) => { resolve(res) }, (reason) => { reject(reason) }, ) }) }) } } // test let promise1 = new MyPromise((resolve, reject) => { setTimeout(() => { resolve(123) }, 2000) }) let promise2 = new MyPromise((resolve, reject) => { setTimeout(() => { resolve(1234) }, 1000) }) MyPromise.all([promise1, promise2]).then((res) => { console.log(res) window.test = res }) // MyPromise.race([promise1, promise2]).then(res => { // console.log(res); // }); // promise1 // .then( // res => { // console.log(res); //过两秒输出123 // return new MyPromise((resolve, reject) => { // setTimeout(() => { // resolve(\"success\"); // }, 1000); // }); // }, // err => { // console.log(err); // } // ) // .then( // res => { // console.log(res); // }, // err => { // console.log(err); // } // ); copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter1/limitRequest.html":{"url":"Chapter1/limitRequest.html","title":"异步并发","keywords":"","body":"异步并发 限制异步操作的并发数量，且保证其执行顺序 class LimitRequest { constructor(max) { this.max = max // 最大并发数量 this.count = 0 // 当前执行数量 this.queueTask = [] // 待执行的任务队列 } call = (fn, ...args) => { return new Promise((resolve, reject) => { const task = this.createTask(fn, args, resolve, reject) if (this.count >= this.max) { this.queueTask.push(task) } else { task() } }) } createTask = (fn, args, resolve, reject) => { return () => { fn(...args) .then(resolve, reject) .finally(() => { this.count-- if (this.queueTask.length) { const task = this.queueTask.shift() task() } }) this.count++ } } } // test const request = ()=> { return new Promise((resolve)=> { setTimeout(()=> { console.log(111) resolve() },3000) }) } let lr = new LimitRequest(3) for(let i = 0;i copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter1/深拷贝.html":{"url":"Chapter1/深拷贝.html","title":"深拷贝","keywords":"","body":"深拷贝 copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter2/":{"url":"Chapter2/","title":"第二章 css","keywords":"","body":"第二章 css copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter2/基础知识.html":{"url":"Chapter2/基础知识.html","title":"基础知识","keywords":"","body":"基础知识 盒模型 水平垂直居中 固定宽高和不固定宽高 页面布局 两栏三栏布局 css 解析顺序 是逆向解析 css 开启硬件加速 transform translate3d flex float 元素写在正常元素的前面 copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter2/mouseEvent距离相关.html":{"url":"Chapter2/mouseEvent距离相关.html","title":"鼠标点击距离相关","keywords":"","body":"鼠标点击距离相关 一图胜千言 copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter3/":{"url":"Chapter3/","title":"第三章 html","keywords":"","body":"第三章 html copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter3/基础知识.html":{"url":"Chapter3/基础知识.html","title":"基础知识","keywords":"","body":"基础知识 details summary 标签 details 配合 summary 实现折叠, 会有一个缺省的 summary,中文环境下是 \"详细信息\" ,如果我们手动设置 ，就会覆盖掉缺省的. 中除了 元素是始终显示的外，其他部分都受到 details 标签中 open 属性的影响，产生对应的显隐效果。 默认的样式会有一个三角实心箭头，可以通过修改样式后去除. .details-reset { /* Remove marker added by the display: list-item browser default --> */ summary { list-style: none; } /* Remove marker added by details polyfill */ summary::before { display: none; } /* Remove marker added by Chrome */ summary::-webkit-details-marker { display: none; } } scrollingElement let scrollHeight = document.documentElement.scrollHeight || document.body.scrollHeight; let scrollHeight = document.scrollingElement.scrollHeight; 标准模式返回 documentElement，怪异模式返回 body 滚动结束后，强制滚动到指定元素 ul { scroll-snap-type: x mandatory; li { scroll-snap-align: start; } } copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter4/":{"url":"Chapter4/","title":"第四章 框架","keywords":"","body":"第四章 框架 copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter4/react.html":{"url":"Chapter4/react.html","title":"react","keywords":"","body":"react react 推荐使用组合而不是继承 组件开发常用 render props，分离 render 的是无状态组件 高阶组件 常用 组件参数 、 属性代理 和 反向继承 React hooks useEffect 依赖需要清楚指定，应当避免造成死循环 useEffect(() => { props.onChange(props.id); }, [props.onChange, props.id]); class App { render() { return ( this.setState({ id })} /> ); } } 上例代码会造成死循环 useMemo useCallback useMemo 和 useCallback 都会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行；并且这两个 hooks 都返回缓存的值，useMemo 返回缓存的变量，useCallback 返回缓存的函数。 useMemo 使用范例 export default function WithMemo() { const [count, setCount] = useState(1); const [val, setValue] = useState(''); const expensive = useMemo(() => { console.log('compute'); let sum = 0; for (let i = 0; i {count}-{expensive} {val} setCount(count + 1)}>+c1 setValue(event.target.value)}/> ; useCallback 使用范例 function Parent() { const [count, setCount] = useState(1); const [val, setVal] = useState(''); const callback = useCallback(() => { return count; }, [count]); return ( {count} setCount(count + 1)}>+ setVal(event.target.value)} /> ); } function Child({ callback }) { const [count, setCount] = useState(() => callback()); useEffect(() => { setCount(callback()); }, [callback]); return {count}; } copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter4/vue.html":{"url":"Chapter4/vue.html","title":"vue","keywords":"","body":"vue v-show v-show 控制显隐，是通过 js 代码去修改元素的 element style。如果 value 为 false，设置 display: none；如果 value 为 true，清除 display 属性。所以 value 为 true 时，只是将 element style 中的 display 效果清除，并不能覆盖 css 中的 display 样式。 react 和 vue 的 diff 过程有什么区别 React diff 的是 Dom，而 Vue diff 的是数据。 React：你给我一个数据，我根据这个数据生成一个全新的 Virtual DOM，然后跟我上一次生成的 Virtual DOM 去 diff，得到一个 Patch，然后把这个 Patch 打到浏览器的 DOM 上去。完事。并且这里的 Patch 显然不是完整的 Virtual DOM，而是新的 Virtual DOM 和上一次的 Virtual DOM 经过 diff 后的差异化的部分。 Vue: 在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。 响应式原理 - 简单模拟代码 uid = 0 class Dep { subs = [] id = uid++ addSub(sub) { this.subs.push(sub) } depend() { if (Dep.target) { Dep.target.addDep(this) } } notify() { this.subs.forEach(sub => sub.run()) } } Dep.target = null function observe(data) { if (data.__ob__) return data && Object.keys(data).forEach(key => { let val = data[key] const dep = new Dep() Object.defineProperty(data, key, { enumerable: true, configurable: true, get() { dep.depend() return val }, set(newVal) { if (newVal !== newVal || newVal === val) return val = newVal dep.notify() } }) }) Object.defineProperty(data, '__ob__', { configurable: true, enumerable: false, value: true, writable: true }) } class Watcher { constructor(data, exp, callback) { this.cb = callback this.deps = {} this.exp = exp // 获取得到数据的函数 this.getter = this.parseExp(exp.trim()) this.data = data this.value = this.get() } addDep(dep) { if (!this.deps[dep.id]) { dep.addSub(this) this.deps[dep.id] = dep } } get() { Dep.target = this let value = this.getter.call(this.data, this.data) Dep.target = null return value } run() { let value = this.get() let oldValue = this.value if (value !== oldValue) { this.value = value this.cb.call(null, value, oldValue) } } parseExp(exp) { if (/[^\\w.$]/.test(exp)) return let exps = exp.split('.') return function (obj) { return obj[exps[1]] } } } // 监测函数 function $watch(data, exp, cb) { observe(data) new Watcher(data, exp, cb) } //test let a = { b: 100, c: 200 } const callback = function (newValue, oldValue) { console.log(`新值为：${newValue}，旧值为：${oldValue}`) } $watch(a, 'a.b', callback) $watch(a, 'a.c', callback) a.b = 101 copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter4/microFramework.html":{"url":"Chapter4/microFramework.html","title":"微前端架构","keywords":"","body":"微前端架构 微前端已经继模块化，组件化之后作为另一种前端架构模式逐渐被业内所接受，在大型的ToB的中后台企业级应用开发场景下，会扮演越来越重要的角色 起源 微前端的概念是随着后端微服务的兴起，导致业务团队被分割为不同的小的开发团队，每个团队中有前后端，测试等角色，后端服务间可以通过http或者rpc互相调用，也可以通过api gateway进行接口的集成聚合，随之而来的是希望前端团队也能够独立开发微应用，然后在前端某个阶段(build,runtime)将这些微应用聚合起来，形成一个完整的大型web应用。通常来说，具有以下几个特点： 独立开发、独立部署、增量更新 与技术栈无关 运行时隔离与共享 单页应用的体验 Web集成方式 构建时集成，例如 git sub module 或 npm package 服务端模版集成，通过nginx访问 运行时Iframe集成 运行时js集成 web components 微前端single-spa 微前端总体分为一下三类 single-spa标准子应用 : 可以通过single-spa对应不同路由渲染不同组件，通常是一个完整的子应用； single-spa parcels : 一个parcel通常不和路由关联，仅仅是页面上的某一个区域 utility module : 独立开发的一些子模块，不渲染页面，只会执行一些公共逻辑 copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter5/":{"url":"Chapter5/","title":"第五章 webpack","keywords":"","body":"第五章 webpack copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter5/打包分块.html":{"url":"Chapter5/打包分块.html","title":"第1节：打包分块","keywords":"","body":"第1节：打包分块 Bundle filename: [name]:[contenthash].js hash文件名: hash chunkhash contenthash hash针对的是每一次构建（build）而言,关心的是整体项目的变化 chunkhash该chunk所属的内容发生了变化才会改变 该哈希根据的是文件的内容 copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter5/loader.html":{"url":"Chapter5/loader.html","title":"第2节：loader","keywords":"","body":"第 2 节：loader loader 是 nodejs 的一个模块 const loaderUtils = require(\"loader-utils\") module.exports = function (source) { const options = loaderUtils.getOptions(this) // 获取loader option参数 // 返回其他结果 // 当你使用 this.callback 返回内容时，该 Loader 必须返回 undefined， // this.callback(null, source, sourceMaps) // 异步情况 // var callback = this.async() // someAsyncOperation(source, function (err, result, sourceMaps, ast) { // // 通过 callback 返回异步执行后的结果 // callback(err, result, sourceMaps, ast) // }) return source } copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter5/plugin.html":{"url":"Chapter5/plugin.html","title":"第3节：plugin","keywords":"","body":"第 3 节：plugin class BasicPlugin { // 在构造函数中获取用户给该插件传入的配置 constructor(options) {} // Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象 apply(compiler) { compiler.plugin(\"compilation\", function (compilation) {}) } } // 导出 Plugin module.exports = BasicPlugin /** * 广播出事件 * event-name 为事件名称，注意不要和现有的事件重名 * params 为附带的参数 */ compiler.apply(\"event-name\", params) /** * 监听名称为 event-name 的事件，当 event-name 事件发生时，函数就会被执行。 * 同时函数中的 params 参数为广播事件时附带的参数。 */ compiler.plugin(\"event-name\", function (params) {}) module.exports = { plugins: [ // 在初始化 EndWebpackPlugin 时传入了两个参数，分别是在成功时的回调函数和失败时的回调函数； new EndWebpackPlugin( () => { // Webpack 构建成功，并且文件输出了后会执行到这里，在这里可以做发布文件操作 }, (err) => { // Webpack 构建失败，err 是导致错误的原因 console.error(err) }, ), ], } class EndWebpackPlugin { constructor(doneCallback, failCallback) { // 存下在构造函数中传入的回调函数 this.doneCallback = doneCallback this.failCallback = failCallback } apply(compiler) { compiler.plugin(\"done\", (stats) => { // 在 done 事件中回调 doneCallback this.doneCallback(stats) }) compiler.plugin(\"failed\", (err) => { // 在 failed 事件中回调 failCallback this.failCallback(err) }) } } // 导出插件 module.exports = EndWebpackPlugin copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter6/":{"url":"Chapter6/","title":"第六章 shell","keywords":"","body":"第六章 shell copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter6/shell.html":{"url":"Chapter6/shell.html","title":"第1节：shell小脚本","keywords":"","body":"第 1 节：shell 小脚本 循环找出指定后缀的文件，并且追加写入某一文件 for i in $(find ~/projects/every-record-new/src \\( -name \"*.js\" -o -name \"*.html\" -o -name \"*.css\" \\)) do cat $i >> ~/test.txt done copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter7/":{"url":"Chapter7/","title":"第七章 git","keywords":"","body":"第七章 git copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter7/git相关配置.html":{"url":"Chapter7/git相关配置.html","title":"第1节：git配置","keywords":"","body":"第 1 节：git 配置 多账户配置 # github key Host github HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github Host gitlab HostName gitlab.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter8/":{"url":"Chapter8/","title":"第八章 IT知识","keywords":"","body":"第八章 IT知识 搜集一些IT知识，拓宽自己的知识储备 😄 copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter8/Http.html":{"url":"Chapter8/Http.html","title":"第1节：http相关","keywords":"","body":"第1节：http相关 这篇文章写的很全面，建议细读，内容太多一次性可能记不住，多看几次就好了 七层网络模型 &#x1F603; 很多人怕是记不全这七层网络模型，作为软件工程科班出身的程序员，这实在是不应该 从上到下依次为: 应用层 - 表示层 - 会话层 - 传输层 - 网络层 - 数据链路层 - 物理层 http1.0 http1.1 http2.0 HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。 HTTP 1.1支持持久连接（HTTP/1.1的默认模式使用带流水线的持久连接），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。 HTTP 1.1状态代码及其含义 状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值： 1xx：指示信息--表示请求已接收，继续处理 2xx：成功--表示请求已被成功接收、理解、接受 3xx：重定向--要完成请求必须进行更进一步的操作 4xx：客户端错误--请求有语法错误或请求无法实现 5xx：服务器端错误--服务器未能实现合法的请求 HTTP/2是HTTP协议自1999年HTTP1.1发布后的首个更新，主要基于SPDY协议。 HTTP2.0的特点是：在不改动HTTP语义、方法、状态码、URI及首部字段的情况下，大幅度提高了web性能。 copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter8/browser.html":{"url":"Chapter8/browser.html","title":"第2节：浏览器相关","keywords":"","body":"第2节：浏览器相关 缓存 元素渲染（重绘 回流） web存储 事件机制 - eventloop gc 性能 copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter9/":{"url":"Chapter9/","title":"第九章 算法","keywords":"","body":"第九章 算法 copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter9/排序.html":{"url":"Chapter9/排序.html","title":"第1节：排序","keywords":"","body":"第1节：排序 copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter9/深度、广度遍历.html":{"url":"Chapter9/深度、广度遍历.html","title":"第2节：bfs dfs","keywords":"","body":"第 2 节：bfs dfs 以 dom 节点的遍历为例 深度优先遍历 dfs 递归 function dfs(node, List = []) { if (node) { List.push(node) const children = node.children for (let i = 0; i 非递归 function dfs(node) { const List = [] if (node) { const stack = [] stack.push(node) while (stack.length) { const item = stack.pop() List.push(item) const children = item.children for (let i = children.length - 1; i >= 0; i--) { stack.push(children[i]) } } } return List } 广度优先遍历 bfs 递归 ,采用循环遍历+指针的方式 function bfs(node) { if (!node) return const result = [node] function _bfs(index) { const el = result[index] if (el) { const cs = el.children for (let i = 0; i 非递归，普通 function bfs(node) { const List = [] if (node) { const queue = [] queue.unshift(node) while (queue.length) { const item = queue.shift() List.push(item) const children = item.children for (let i = 0; i 非递归 ，指针方式 function bfs(node) { if (!node) return const result = [node] let index = 0 while (index copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter9/动态规划.html":{"url":"Chapter9/动态规划.html","title":"第3节：dp","keywords":"","body":"第3节：dp copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter9/贪心.html":{"url":"Chapter9/贪心.html","title":"第4节：贪心","keywords":"","body":"第4节：贪心 在考虑问题时，考虑当前情况下的最优解，而不是从整体考虑。所以求的是局部最优解. copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter9/二分.html":{"url":"Chapter9/二分.html","title":"第5节：分治","keywords":"","body":"第5节：分治 copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter9/回溯.html":{"url":"Chapter9/回溯.html","title":"第6节：回溯","keywords":"","body":"第6节：回溯 copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter10/":{"url":"Chapter10/","title":"第十章 面试","keywords":"","body":"第十章 面试 copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "},"Chapter10/算法.html":{"url":"Chapter10/算法.html","title":"第1节：算法","keywords":"","body":"第 1 节：算法 斐波那契变种 fn(2) => [1,1,2,3,5,8,13] fn(3) => [1,1,1,3,5,9,14] fn(4) => [1,1,1,1,4,7,13,25] 求 fn(n)中的第 index 个元素 fn(key,index) function fn(key, index) { const map = {} function fib(n) { if (map[n]) return map[n] if (n 单词反转 /** * 输入：www.toutiao.com.cn 输出：cn.com.toutiao.www */ function reversWords(str) { let result = \"\" let words = \"\" let index = 0 const length = str.length while (index 折半查找 // 折半 function halfFind(arr, target) { function find(s, e) { if (s >= e) return null const index = ((s + e) / 2) | 0 if (arr[index] === target) return index else if (arr[index] > target) return find(s, index - 1) else return find(index + 1, e) } return find(0, arr.length - 1) } //test halfFind([1, 2, 3, 4, 5, 6, 7, 8], 7) 排列组合 4.1 字符串全排列 // 字符串全排列 function list(str) { const result = [] if (str.length > 1) { for (let i = 0; i 4.2 数组排列组合 (商品 sku 组合) // [a,b] [c,d] [e,f] function skuList(array) { const result = [] let tarr = [] function list(arr, index) { for (let i = 0; i 实现 destructuringArray // destructuringArray( [1,[2,4],3], \"[a,[b],c]\" ); // result // { a:1, b:2, c:3 } function destructuringArray(arr, str) { // 转换字符串，提取变量 const _str = str.replace(/\\w/g, `\"$&\"`) const arrStr = JSON.parse(_str) const obj = {} function deepTraval(nums, strs) { if (Array.isArray(strs)) { for (let i = 0; i copyright reserved all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 06:41:23 "}}